---
// src/layouts/Base.astro
import "../styles/tailwind.css";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";

export interface Props {
  title?: string;
  description?: string;
  canonical?: string;          // optional explicit canonical override
  jsonLd?: any | any[];        // optional JSON-LD object or array of objects
  includeDefaultSchema?: boolean; // set false to disable Organization/WebSite schema
}

const {
  title = "Defunct Brands Archive",
  description = "Browse discontinued and defunct brands by category, Aâ€“Z, decade, and fate.",
  canonical: canonicalProp,
  jsonLd = [],
  includeDefaultSchema = true,
} = Astro.props;

// Build a canonical URL from Astro.site + current pathname if not provided
const siteOrigin = Astro.site?.origin || "https://vanishedbrands.com";
const pathname   = Astro.url?.pathname || "/";
const canonical  = canonicalProp || new URL(pathname, siteOrigin).toString();

// Safe limits for SERP
const trim = (s:string, n:number) => (s && s.length > n ? s.slice(0, n - 1).trimEnd() + "â€¦" : s);
const TITLE = trim(title, 60);
const DESC  = trim(description, 160);

// Safely stringify JSON for inline <script> (avoid breaking on </script>, <, U+2028/U+2029)
const toSafeJson = (obj: any) =>
  JSON.stringify(obj ?? {})
    .replace(/<\/script/gi, '<\\/script')
    .replace(/</g, '\\u003c')
    .replace(/\u2028|\u2029/g, '');

// Default site-wide schema (minimal)
const ORG_NAME = "Vanished Brands";
const defaultSchema = includeDefaultSchema
  ? [
      {
        "@context": "https://schema.org",
        "@type": "Organization",
        name: ORG_NAME,
        url: siteOrigin,
      },
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        name: ORG_NAME,
        url: siteOrigin,
        // Add SearchAction here if/when you launch /search?q=
      },
    ]
  : [];

// Normalize jsonLd to an array and append defaults
const jsonLdArray: any[] = [
  ...(Array.isArray(jsonLd) ? jsonLd : (jsonLd ? [jsonLd] : [])),
  ...defaultSchema,
];

// Load curated brand JSON (used for random + seeds)
const mods = import.meta.glob("/src/content/brands/*.json", { eager: true }) as Record<string, any>;

const fileSlugs: string[] = Object.entries(mods)
  .map(([p, mod]) => {
    const data = (mod as any).default ?? mod;
    // Prefer explicit slug; else derive from filename
    return (
      data?.slug ??
      (p.split("/").pop() || "")
        .replace(/\.public\.json$/i, "")  // tolerate legacy names
        .replace(/\.json$/i, "")
    );
  })
  .filter(Boolean);

const FALLBACK_SLUG = fileSlugs[0] || "aim";

/* Inline seed (first N slugs) + a simple version key for cache */
const INLINE_SEED = fileSlugs.slice(0, 64);
const BRAND_INDEX_VER = `${fileSlugs.length}:${INLINE_SEED[0] || ""}:${INLINE_SEED[INLINE_SEED.length - 1] || ""}`;
---
<html lang="en" class="h-full">
  <head>
    <meta charset="utf-8" />
    <title>{TITLE}</title>
    <meta name="description" content={DESC} />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="robots" content="max-snippet:-1, max-image-preview:large, max-video-preview:-1" />

    <!-- Canonical & Open Graph -->
    <link rel="canonical" href={canonical} />
    <meta property="og:url" content={canonical} />
    <meta property="og:title" content={TITLE} />
    <meta property="og:description" content={DESC} />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content={TITLE} />
    <meta name="twitter:description" content={DESC} />

    <!-- JSON-LD (safely inlined) -->
    {jsonLdArray.map((obj) => (
      <script type="application/ld+json" is:inline set:html={toSafeJson(obj)} />
    ))}

    <!-- Allow pages to inject extra SEO / scripts -->
    <slot name="head" />

    <!-- Theme boot -->
    <script is:inline>
      (function () {
        const KEY = 'theme';
        const saved = localStorage.getItem(KEY);
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = saved || (prefersDark ? 'dark' : 'light');
        if (theme === 'dark') document.documentElement.classList.add('dark');
        document.documentElement.dataset.theme = theme;
      })();
    </script>

    <!-- Optional: better mobile address-bar color per theme -->
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0b0b0f" media="(prefers-color-scheme: dark)">

    <!-- Tiny list of slugs (seed) + version for cache -->
    <script
      id="__brand_slugs_inline"
      type="application/json"
      data-ver={BRAND_INDEX_VER}
      is:inline
      set:html={toSafeJson(INLINE_SEED)}
    />

    <!-- Hint the browser it may fetch the tiny text list soon -->
    <link rel="preload" href="/brand-slugs.txt" as="fetch" crossorigin="anonymous" />

    <!-- Favicons -->
    <link rel="icon" href="/favicon.ico?v=2" sizes="any" type="image/x-icon" />
    <link rel="icon" href="/favicon-32x32.png?v=2" type="image/png" sizes="32x32" />
    <link rel="icon" href="/favicon-16x16.png?v=2" type="image/png" sizes="16x16" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png?v=2" />

    <!-- Minimal skip-link styles (kept here to avoid needing a new CSS file) -->
    <style is:inline>
      .skip-link{position:absolute;left:-9999px;top:0;background:#111827;color:#fff;padding:.5rem .75rem;border-radius:.5rem;z-index:10000}
      .skip-link:focus{left:1rem;top:1rem;outline:2px solid #6366f1;outline-offset:2px}
      .fade-out{transition:opacity .12s ease-in;opacity:.2}
    </style>
  </head>

  <body class="min-h-screen flex flex-col bg-white text-gray-900 dark:bg-[#0b0b0f] dark:text-slate-100">
    <!-- Skip link for keyboard users (first focusable in body) -->
    <a href="#main" class="skip-link">Skip to content</a>

    <!-- Header -->
    <Header allSlugs={fileSlugs} fallbackSlug={FALLBACK_SLUG} />

    <!-- Main grows to push footer down; tabindex enables skip-link focus -->
    <main
      id="main"
      class="flex-1 max-w-[1040px] mx-auto px-4"
      aria-labelledby="brand-title"
      tabindex="-1"
    >
      <slot />
    </main>

    <!-- Footer -->
    <Footer fallbackSlug={FALLBACK_SLUG} />

    <!-- ðŸ”Š Screen-reader live announcements -->
    <div id="live-region" aria-live="polite" class="sr-only"></div>

    <!-- Random loader: no JSON parsing, uses /brand-slugs.txt + localStorage cache + idle warmup -->
    <script is:inline>
      (function () {
        const INLINE = document.getElementById("__brand_slugs_inline");
        const VER = INLINE?.getAttribute("data-ver") || "v1";
        const KEY = "__BRAND_SLUGS__";

        function setCache(list) {
          try { localStorage.setItem(KEY, JSON.stringify({ v: VER, l: list })); } catch {}
        }
        function getCache() {
          try {
            const x = JSON.parse(localStorage.getItem(KEY) || "null");
            if (x && x.v === VER && Array.isArray(x.l) && x.l.length) return x.l;
          } catch {}
          return null;
        }

        async function fetchTxt() {
          const r = await fetch("/brand-slugs.txt", { cache: "force-cache", credentials: "same-origin" });
          if (!r.ok) throw new Error("fetch failed");
          const text = await r.text();
          return text.split("\n").map(s => s.trim()).filter(Boolean);
        }

        async function ensureSlugs() {
          const cached = getCache();
          if (cached) return cached;

          if (INLINE?.textContent) {
            try {
              const seed = JSON.parse(INLINE.textContent);
              if (Array.isArray(seed) && seed.length) {
                setCache(seed);
                fetchTxt().then(list => list.length && setCache(list)).catch(() => {});
                return seed;
              }
            } catch {}
          }

          try {
            const list = await fetchTxt();
            if (list.length) { setCache(list); return list; }
          } catch {}

          const seen = new Set(), out = [];
          document.querySelectorAll('a[href^="/brand/"]').forEach(a => {
            const m = (a.getAttribute('href') || '').match(/^\/brand\/([^\/?#]+)\/?/);
            if (m && m[1] && !seen.has(m[1])) { seen.add(m[1]); out.push(m[1]); }
          });
          return out;
        }

        function pickOther(list) {
          const cur = (location.pathname.match(/^\/brand\/([^\/?#]+)\/?/) || [,""])[1];
          const pool = list.length > 1 ? list.filter(s => s !== cur) : list;
          return pool[(Math.random() * pool.length) | 0];
        }

        document.addEventListener("click", async function (e) {
          const a = e.target && (e.target.closest?.("[data-random], #random-brand"));
          if (!a) return;
          e.preventDefault();

          const live = document.getElementById("live-region");
          if (live) live.textContent = "Loading a random brandâ€¦";

          try {
            const slugs = await ensureSlugs();
            const pick = pickOther(slugs);
            if (pick) {
              try { document.body.classList.add("fade-out"); } catch {}
              setTimeout(() => { location.href = "/brand/" + pick + "/"; }, 80);
            }
          } catch {
            const href = a.getAttribute("href");
            if (href) location.href = href;
          }
        }, false);

        const warm = () => { ensureSlugs().catch(() => {}); };
        if ("requestIdleCallback" in window) requestIdleCallback(warm);
        else setTimeout(warm, 250);

        // @ts-ignore
        window.__goRandomBrand = function(ev){
          ev?.preventDefault?.();
          ensureSlugs().then(slugs => {
            const pick = pickOther(slugs || []);
            if (pick) location.href = "/brand/" + pick + "/";
          });
        };
      })();
    </script>
  </body>
</html>
