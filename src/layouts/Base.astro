---
import "../styles/tailwind.css";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";

export interface Props {
  title?: string;
  description?: string;
  canonical?: string;          // optional explicit canonical override
  jsonLd?: any | any[];        // optional JSON-LD object or array of objects
}

const {
  title = "Defunct Brands Archive",
  description = "Browse discontinued and defunct brands by category, Aâ€“Z, decade, and fate.",
  canonical: canonicalProp,
  jsonLd = []
} = Astro.props;

// Build a canonical URL from Astro.site + current pathname if not provided
const siteOrigin = Astro.site?.origin || "https://vanishedbrands.com";
const pathname   = Astro.url?.pathname || "/";
const canonical  = canonicalProp || new URL(pathname, siteOrigin).toString();

// Safe limits for SERP
const trim = (s:string, n:number) => (s && s.length > n ? s.slice(0, n - 1).trimEnd() + "â€¦" : s);
const TITLE = trim(title, 60);
const DESC  = trim(description, 160);

// Normalize jsonLd to an array
const jsonLdArray: any[] = Array.isArray(jsonLd) ? jsonLd : (jsonLd ? [jsonLd] : []);

/** Load curated brand JSON (used for random + seeds) */
const mods = import.meta.glob("/src/content/brands/*.json", { eager: true }) as Record<string, any>;

const fileSlugs: string[] = Object.entries(mods)
  .map(([p, mod]) => {
    const data = (mod as any).default ?? mod;
    // Prefer explicit slug; else derive from filename
    return (
      data?.slug ??
      (p.split("/").pop() || "")
        .replace(/\.public\.json$/i, "")  // tolerate legacy names
        .replace(/\.json$/i, "")
    );
  })
  .filter(Boolean);

const FALLBACK_SLUG = fileSlugs[0] || "aim";

/* Inline seed (first N slugs) + a simple version key for cache */
const INLINE_SEED = fileSlugs.slice(0, 64);
const BRAND_INDEX_VER = `${fileSlugs.length}:${INLINE_SEED[0] || ""}:${INLINE_SEED[INLINE_SEED.length - 1] || ""}`;
---

<html lang="en" class="h-full">
  <head>
    <meta charset="utf-8" />
    <title>{TITLE}</title>
    <meta name="description" content={DESC} />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Canonical & Open Graph -->
    <link rel="canonical" href={canonical} />
    <meta property="og:url" content={canonical} />
    <meta property="og:title" content={TITLE} />
    <meta property="og:description" content={DESC} />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content={TITLE} />
    <meta name="twitter:description" content={DESC} />

    <!-- JSON-LD (emit actual JSON; not literal JSX) -->
    {jsonLdArray.map((obj) => (
      <script type="application/ld+json" is:inline>
        {JSON.stringify(obj)}
      </script>
    ))}

    <!-- Allow pages to inject extra SEO / scripts -->
    <slot name="head" />

    <!-- Theme boot -->
    <script is:inline>
      (function () {
        const KEY = 'theme';
        const saved = localStorage.getItem(KEY);
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = saved || (prefersDark ? 'dark' : 'light');
        if (theme === 'dark') document.documentElement.classList.add('dark');
        document.documentElement.dataset.theme = theme;
      })();
    </script>

    <!-- Optional: better mobile address-bar color per theme -->
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0b0b0f" media="(prefers-color-scheme: dark)">

    <!-- Tiny list of slugs (seed) + version for cache -->
    <script id="__brand_slugs_inline" type="application/json" data-ver={BRAND_INDEX_VER}>
      {JSON.stringify(INLINE_SEED)}
    </script>

    <!-- Hint the browser it may fetch the tiny text list soon -->
    <link rel="preload" href="/brand-slugs.txt" as="fetch" crossorigin="anonymous" />
  </head>

  <body class="min-h-full bg-white text-gray-900 dark:bg-[#0b0b0f] dark:text-slate-100">
    <!-- Skip link for keyboard users -->
    <a href="#main" class="skip-link">Skip to content</a>

    <!-- Header -->
    <Header allSlugs={fileSlugs} fallbackSlug={FALLBACK_SLUG} />

    <main id="main" class="max-w-[1040px] mx-auto px-4" aria-labelledby="brand-title">
      <slot />
    </main>

    <!-- Footer -->
    <Footer fallbackSlug={FALLBACK_SLUG} />

    <!-- ðŸ”Š Screen-reader live announcements (Footer also includes one; keeping here is harmless) -->
    <div id="live-region" aria-live="polite" class="sr-only"></div>

    <!-- Random loader: no JSON parsing, uses /brand-slugs.txt + localStorage cache + idle warmup -->
    <script is:inline>
      (function () {
        const INLINE = document.getElementById("__brand_slugs_inline");
        const VER = INLINE?.getAttribute("data-ver") || "v1";
        const KEY = "__BRAND_SLUGS__";

        function setCache(list) {
          try { localStorage.setItem(KEY, JSON.stringify({ v: VER, l: list })); } catch {}
        }
        function getCache() {
          try {
            const x = JSON.parse(localStorage.getItem(KEY) || "null");
            if (x && x.v === VER && Array.isArray(x.l) && x.l.length) return x.l;
          } catch {}
          return null;
        }

        async function fetchTxt() {
          const r = await fetch("/brand-slugs.txt", { cache: "force-cache", credentials: "same-origin" });
          if (!r.ok) throw new Error("fetch failed");
          const text = await r.text();
          return text.split("\n").map(s => s.trim()).filter(Boolean);
        }

        async function ensureSlugs() {
          // 1) localStorage cache
          const cached = getCache();
          if (cached) return cached;

          // 2) inline seed (first 64 slugs), then upgrade in background
          if (INLINE?.textContent) {
            try {
              const seed = JSON.parse(INLINE.textContent);
              if (Array.isArray(seed) && seed.length) {
                setCache(seed);
                fetchTxt().then(list => list.length && setCache(list)).catch(() => {});
                return seed;
              }
            } catch {}
          }

          // 3) tiny text endpoint
          try {
            const list = await fetchTxt();
            if (list.length) { setCache(list); return list; }
          } catch {}

          // 4) last resort: scrape visible links
          const seen = new Set(), out = [];
          document.querySelectorAll('a[href^="/brand/"]').forEach(a => {
            const m = (a.getAttribute('href') || '').match(/^\/brand\/([^\/?#]+)\/?/);
            if (m && m[1] && !seen.has(m[1])) { seen.add(m[1]); out.push(m[1]); }
          });
          return out;
        }

        function pickOther(list) {
          const cur = (location.pathname.match(/^\/brand\/([^\/?#]+)\/?/) || [,""])[1];
          const pool = list.length > 1 ? list.filter(s => s !== cur) : list;
          return pool[(Math.random() * pool.length) | 0];
        }

        // Delegated click; supports sync or async slug load
        document.addEventListener("click", async function (e) {
          const a = e.target && (e.target.closest?.("[data-random], #random-brand"));
          if (!a) return;

          e.preventDefault();

          const live = document.getElementById("live-region");
          if (live) live.textContent = "Loading a random brandâ€¦";

          try {
            const slugs = await ensureSlugs();
            const pick = pickOther(slugs);
            if (pick) {
              try { document.body.classList.add("fade-out"); } catch {}
              setTimeout(() => { location.href = "/brand/" + pick + "/"; }, 80);
            }
          } catch {
            const href = a.getAttribute("href");
            if (href) location.href = href;
          }
        }, false);

        // Prewarm cache on first page view (non-blocking)
        const warm = () => { ensureSlugs().catch(() => {}); };
        if ("requestIdleCallback" in window) requestIdleCallback(warm);
        else setTimeout(warm, 250);

        // Optional: expose for console testing or inline onclick fallbacks
        window.__goRandomBrand = function(ev){ ev?.preventDefault?.(); ensureSlugs().then(slugs => {
          const pick = pickOther(slugs || []);
          if (pick) location.href = "/brand/" + pick + "/";
        }); };
      })();
    </script>
  </body>
</html>
