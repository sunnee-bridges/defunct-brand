---
import "../styles/tailwind.css";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";

export interface Props { title?: string; description?: string; }

const {
  title = "Defunct Brands Archive",
  description = "Browse discontinued and defunct brands by category, Aâ€“Z, decade, and fate."
} = Astro.props;

/** ðŸ”§ Same loader as index.astro */
const mods = import.meta.glob("/src/content/brands/*.json", { eager: true }) as Record<string, any>;

const fileSlugs: string[] = Object.entries(mods)
  .map(([p, mod]) => {
    const data = (mod as any).default ?? mod;
    // prefer explicit slug; else derive from filename
     return data?.slug ?? (p.split("/").pop() || "")
     .replace(/\.public\.json$/i, "")
     .replace(/\.json$/i, "");
  })
  .filter(Boolean);

const FALLBACK_SLUG = fileSlugs[0] || "aim";

/* Inline seed (first N slugs) + a simple version key for cache */
const INLINE_SEED = fileSlugs.slice(0, 64);
const BRAND_INDEX_VER = `${fileSlugs.length}:${INLINE_SEED[0] || ""}:${INLINE_SEED[INLINE_SEED.length - 1] || ""}`;
---

<html lang="en" class="h-full">
  <head>
    <meta charset="utf-8" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Allow pages to inject extra SEO -->
    <slot name="head" />

    <!-- Theme boot -->
    <script is:inline>
      (function () {
        const KEY = 'theme';
        const saved = localStorage.getItem(KEY);
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = saved || (prefersDark ? 'dark' : 'light');
        if (theme === 'dark') document.documentElement.classList.add('dark');
        document.documentElement.dataset.theme = theme;
      })();
    </script>

    <!-- Optional: better mobile address-bar color per theme -->
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0b0b0f" media="(prefers-color-scheme: dark)">

    <!-- Tiny list of slugs (seed) + version for cache -->
    <script id="__brand_slugs_inline" type="application/json" data-ver={BRAND_INDEX_VER}>
      {JSON.stringify(INLINE_SEED)}
    </script>

    <!-- Hint the browser it may fetch the tiny text list soon -->
    <link rel="preload" href="/brand-slugs.txt" as="fetch" crossorigin="anonymous" />
  </head>

  <body class="min-h-full bg-white text-gray-900 dark:bg-[#0b0b0f] dark:text-slate-100">
    <!-- Skip link for keyboard users -->
    <a href="#main" class="skip-link">Skip to content</a>

    <!-- Header -->
    <Header allSlugs={fileSlugs} fallbackSlug={FALLBACK_SLUG} />

    <main id="main" class="max-w-[1040px] mx-auto px-4" aria-labelledby="brand-title">
      <slot />
    </main>

    <!-- Footer -->
    <Footer fallbackSlug={FALLBACK_SLUG} />

    <!-- ðŸ”Š Screen-reader live announcements (Footer also includes one; keeping here is harmless) -->
    <div id="live-region" aria-live="polite" class="sr-only"></div>

    <!-- Random loader: no JSON parsing, uses /brand-slugs.txt + localStorage cache + idle warmup -->
    <script is:inline>
      (function () {
        const INLINE = document.getElementById("__brand_slugs_inline");
        const VER = INLINE?.getAttribute("data-ver") || "v1";
        const KEY = "__BRAND_SLUGS__";

        function setCache(list) {
          try { localStorage.setItem(KEY, JSON.stringify({ v: VER, l: list })); } catch {}
        }
        function getCache() {
          try {
            const x = JSON.parse(localStorage.getItem(KEY) || "null");
            if (x && x.v === VER && Array.isArray(x.l) && x.l.length) return x.l;
          } catch {}
          return null;
        }

        async function fetchTxt() {
          const r = await fetch("/brand-slugs.txt", { cache: "force-cache", credentials: "same-origin" });
          if (!r.ok) throw new Error("fetch failed");
          const text = await r.text();
          return text.split("\n").map(s => s.trim()).filter(Boolean);
        }

        async function ensureSlugs() {
          // 1) localStorage cache
          const cached = getCache();
          if (cached) return cached;

          // 2) inline seed (first 64 slugs), then upgrade in background
          if (INLINE?.textContent) {
            try {
              const seed = JSON.parse(INLINE.textContent);
              if (Array.isArray(seed) && seed.length) {
                setCache(seed);
                fetchTxt().then(list => list.length && setCache(list)).catch(() => {});
                return seed;
              }
            } catch {}
          }

          // 3) tiny text endpoint
          try {
            const list = await fetchTxt();
            if (list.length) { setCache(list); return list; }
          } catch {}

          // 4) last resort: scrape visible links
          const seen = new Set(), out = [];
          document.querySelectorAll('a[href^="/brand/"]').forEach(a => {
            const m = (a.getAttribute('href') || '').match(/^\/brand\/([^\/?#]+)\/?/);
            if (m && m[1] && !seen.has(m[1])) { seen.add(m[1]); out.push(m[1]); }
          });
          return out;
        }

        function pickOther(list) {
          const cur = (location.pathname.match(/^\/brand\/([^\/?#]+)\/?/) || [,""])[1];
          const pool = list.length > 1 ? list.filter(s => s !== cur) : list;
          return pool[(Math.random() * pool.length) | 0];
        }

        // Delegated click; supports sync or async slug load
        document.addEventListener("click", async function (e) {
          const a = e.target && (e.target.closest?.("[data-random], #random-brand"));
          if (!a) return;

          e.preventDefault();

          const live = document.getElementById("live-region");
          if (live) live.textContent = "Loading a random brandâ€¦";

          try {
            const slugs = await ensureSlugs();
            const pick = pickOther(slugs);
            if (pick) {
              try { document.body.classList.add("fade-out"); } catch {}
              setTimeout(() => { location.href = "/brand/" + pick + "/"; }, 80);
            }
          } catch {
            const href = a.getAttribute("href");
            if (href) location.href = href;
          }
        }, false);

        // Prewarm cache on first page view (non-blocking)
        const warm = () => { ensureSlugs().catch(() => {}); };
        if ("requestIdleCallback" in window) requestIdleCallback(warm);
        else setTimeout(warm, 250);

        // Optional: expose for console testing or inline onclick fallbacks
        window.__goRandomBrand = function(ev){ ev?.preventDefault?.(); ensureSlugs().then(slugs => {
          const pick = pickOther(slugs || []);
          if (pick) location.href = "/brand/" + pick + "/";
        }); };
      })();
    </script>
  </body>
</html>
