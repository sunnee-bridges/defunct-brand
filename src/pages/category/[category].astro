---
// src/pages/category/[category].astro
import Base from "../../layouts/Base.astro";
import { slugify } from "../../lib/slug.js";
import { CATEGORY_META, labelFor, descFor } from "../../lib/categoryMeta.ts";

/**
 * Curated copy for SEO categories (canonical).
 * Keys MUST be slugified and should match `seo_category` values.
 */
const CATEGORY_META: Record<string, { label?: string; desc?: string }> = {
  "retail": {
    desc:
      "Department stores, specialty shops, and mall icons that shuttered—browse timelines, fates, and what led to the downfall.",
  },
  "retail-entertainment": {
    label: "Retail & Entertainment",
    desc:
      "Video rental, arcades, and music/movie retailers that couldn’t survive the digital turn.",
  },
  "food-beverage": {
    label: "Food & Beverage",
    desc:
      "Cereal, snacks, and soft drinks—limited runs, cult favorites, and why they vanished.",
  },
  "alcoholic-beverages": {
    label: "Alcoholic Beverages",
    desc:
      "Beers, malts, and RTDs that defined eras, then disappeared (and sometimes came back).",
  },
  "consumer-electronics": {
    label: "Consumer Electronics",
    desc:
      "Gadgets we loved—from music players to cameras—retired by smartphones or shifting tastes.",
  },
  "computers-hardware": {
    label: "Computers & Hardware",
    desc:
      "PC makers and components that shaped personal computing before being outpaced by new ecosystems.",
  },
  "mobile-wearables": {
    label: "Mobile & Wearables",
    desc:
      "Phones, PDAs, and smartwatches that set the pace for mobility—then ceded it.",
  },
  "software-internet": {
    label: "Software & Internet",
    desc:
      "Browsers, IM clients, P2P, and e-commerce pioneers—what they built, and why they ended.",
  },
  "video-games-consoles": {
    label: "Video Games & Consoles",
    desc:
      "Hardware and online worlds that battled for the living room—launches, closures, and legacy.",
  },
  // ✅ canonical key matches the rest of the site
  "airline-aviation": {
    label: "Airlines & Aviation",
    desc:
      "Carriers that merged, rebranded, or ceased operations—routes, fleets, and consolidation timelines.",
  },
  "automotive": {
    desc:
      "Marques and halo models that defined eras, from mid-century giants to single-year cult icons.",
  },
  "finance-payments": {
    label: "Finance & Payments",
    desc:
      "Banks, crypto exchanges, and processors—rise, risk, regulation, and collapse.",
  },
  "healthcare-diagnostics": {
    label: "Healthcare & Diagnostics",
    desc:
      "Ambitious med-tech and diagnostics brands—promises, pivots, and regulatory reality.",
  },
};

/** Build-time: enumerate all SEO categories and precompute the items for each */
export async function getStaticPaths() {
  const modules = import.meta.glob("/src/content/brands/*.json", {
    eager: true,
    import: "default",
  }) as Record<string, any>;

  // Normalize & de-dupe by canonical brand slug
  const bySlug = new Map<string, any>();
  for (const raw of Object.values(modules)) {
    const b = raw as any;
    if (!b) continue;

    const brandKey =
      String(b.slug || "").trim().toLowerCase() ||
      slugify(String(b.brand || ""));
    if (!brandKey) continue;

    // Prefer seo_category; fallback to category
    const rawCat = (b.seo_category ?? b.category ?? "").toString().trim();
    if (!rawCat) continue;

    b.__seo_category = slugify(rawCat); // normalized canonical category slug

    if (!bySlug.has(brandKey)) bySlug.set(brandKey, b); // first wins
  }
  const brands = Array.from(bySlug.values());

  // Unique SEO category slugs (sorted)
  const slugs = Array.from(new Set(brands.map((b) => b.__seo_category))).sort();

  // Page props per category
  return slugs.map((catSlug) => {
    const items = brands
      .filter((b) => b.__seo_category === catSlug)
      .sort((a, b) => String(a.brand).localeCompare(String(b.brand)));

    // Derive label from meta (fallback to prettified slug)
    const meta = CATEGORY_META[catSlug] ?? {};
    const label =
      meta.label ||
      catSlug.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());

    return { params: { category: catSlug }, props: { label, catSlug, items, allCats: slugs } };
  });
}

/** Props from getStaticPaths */
const { label, catSlug, items, allCats } = Astro.props;

/** Final render-time guard (belt & suspenders) */
const _seen = new Set<string>();
const uniqueItems = items.filter((b: any) => {
  const k =
    String(b.slug || "").trim().toLowerCase() ||
    slugify(String(b.brand || ""));
  if (!k || _seen.has(k)) return false;
  _seen.add(k);
  return true;
});

/* ---------------- SEO / Canonical / JSON-LD ---------------- */
const categoryPath = `/category/${catSlug}/`;
const siteOrigin = Astro.site?.origin || "https://vanishedbrands.com";
const canonical = Astro.site ? new URL(categoryPath, Astro.site).href : categoryPath;

const title = `Defunct Brands in ${label}`;
const metaDesc = (CATEGORY_META[catSlug]?.desc ??
  `Explore ${uniqueItems.length} defunct or discontinued brands in ${label}.`);

const id = (p: string) => `${siteOrigin}${p.replace(/^\//, "/")}`;

const breadcrumbLd = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "@id": id(`${categoryPath}#breadcrumbs`),
  itemListElement: [
    { "@type": "ListItem", position: 1, name: "Home", item: id("/") },
    { "@type": "ListItem", position: 2, name: "Categories", item: id("/#categories") },
    { "@type": "ListItem", position: 3, name: label, item: canonical },
  ],
};

const itemListLd = {
  "@context": "https://schema.org",
  "@type": "ItemList",
  "@id": id(`${categoryPath}#itemlist`),
  url: canonical,
  name: title,
  itemListOrder: "http://schema.org/ItemListOrderAscending",
  numberOfItems: uniqueItems.length,
  itemListElement: uniqueItems.map((b: any, i: number) => ({
    "@type": "ListItem",
    position: i + 1,
    name: b.brand,
    url: Astro.site
      ? new URL(`/brand/${encodeURIComponent(b.slug)}/`, Astro.site).href
      : `/brand/${encodeURIComponent(b.slug)}/`,
  })),
};

const collectionPageLd = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "@id": id(categoryPath),
  url: canonical,
  name: title,
  description: metaDesc,
  mainEntity: { "@id": itemListLd["@id"] },
};
---

<Base
  title={title}
  description={metaDesc}
  canonical={canonical}
  jsonLd={[collectionPageLd, breadcrumbLd, itemListLd]}
>
  <nav class="mb-4">
    <a href="/" class="chip focus-ring">← Home</a>
  </nav>

  <h1 class="text-2xl md:text-3xl font-bold mb-2">
    {label} — defunct brands
    <span class="ml-2 align-middle inline-flex items-center rounded-full border border-slate-200 bg-white px-2 py-0.5 text-xs font-semibold text-slate-900 dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100">
      {uniqueItems.length}
    </span>
  </h1>

  <p class="text-slate-700 dark:text-slate-300 mb-3">
    {CATEGORY_META[catSlug]?.desc ?? `Browse brands, filter, and sort. A–Z by default.`}
  </p>

  <div class="mb-3 flex flex-wrap items-center gap-3">
    <label for="q" class="text-sm text-slate-600 dark:text-slate-300">Search</label>
    <input id="q" type="search"
           class="w-full md:w-auto flex-1 rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus-ring dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
           placeholder={`Search brands in ${label}…`} inputmode="search" />
    <label for="sort" class="text-sm text-slate-600 dark:text-slate-300">Sort</label>
    <select id="sort"
            class="rounded-md border border-slate-300 bg-white text-slate-900 px-3 py-2 focus-ring dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100">
      <option value="alpha">A → Z</option>
      <option value="start-asc">Oldest founded</option>
      <option value="end-desc">Most recent closure</option>
    </select>
  </div>

  <ul id="brandList" class="m-0 p-0 list-none border-t border-slate-200 dark:border-slate-800">
    {uniqueItems.map((b: any) => {
      const start = b?.active?.start ?? "";
      const end = b?.active?.end ?? "";
      const fate = b?.fate ?? "";

      return (
        <li
          class="relative group cursor-pointer py-3 border-b border-slate-200 dark:border-slate-800
                 hover:bg-slate-50 dark:hover:bg-slate-800/60 transition-colors"
        >
          <a
            href={`/brand/${encodeURIComponent(b.slug)}/`}
            class="stretched-link focus-ring rounded-md"
            aria-label={`${b.brand}${start ? ` (${start}–${end || "?"})` : ""}${fate ? ` • ${fate}` : ""}`}
          ></a>

          <div class="min-w-0 pr-2">
            <span class="font-semibold text-slate-900 dark:text-slate-100 underline-offset-2 group-hover:underline">
              {b.brand}
            </span>
            <span class="ml-1 text-sm text-slate-600 dark:text-slate-400">
              {start ? ` (${start}\u2013${end || "?"})` : ""}{fate ? ` • ${fate}` : ""}
            </span>
          </div>
        </li>
      );
    })}
  </ul>

  <script>
    const $ = (s)=>document.querySelector(s);
    const $$ = (s)=>Array.from(document.querySelectorAll(s));
    const list = $("#brandList");
    const q = $("#q");
    const sortSel = $("#sort");

    function applyFilters() {
      const term = (q.value || "").trim().toLowerCase();
      $$("#brandList > li").forEach(li => {
        const txt = (li.textContent || "").toLowerCase();
        li.style.display = !term || txt.includes(term) ? "" : "none";
      });
    }

    function applySort() {
      const mode = sortSel.value;
      const rows = $$("#brandList > li").filter(li => li.style.display !== "none");
      const getName = (li)=> (li.querySelector("a")?.textContent || "").toLowerCase();
      const getYear = (li, which)=> {
        const t = li.textContent || "";
        const m = t.match(/\((\d{3,4})\u2013(\?|\d{3,4})\)/);
        if (!m) return 0;
        return which === "start" ? parseInt(m[1],10) : (m[2] === "?" ? 0 : parseInt(m[2],10));
      };

      rows.sort((a,b)=>{
        if (mode === "alpha") return getName(a).localeCompare(getName(b));
        if (mode === "start-asc") return getYear(a,"start") - getYear(b,"start") || getName(a).localeCompare(getName(b));
        if (mode === "end-desc") return getYear(b,"end") - getYear(a,"end") || getName(a).localeCompare(getName(b));
        return 0;
      });
      rows.forEach(r => list.appendChild(r));
    }

    function onChange(){ applyFilters(); applySort(); }
    q.addEventListener("input", onChange);
    sortSel.addEventListener("change", onChange);
    onChange();
  </script>
</Base>
